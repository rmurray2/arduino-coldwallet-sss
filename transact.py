from web3 import Web3
import json
import streamlit as st

st.title("Send tokens from a safe contract")
#https://rpc.ftm.tools/
provider = st.text_input("Provider:", "https://mainnet.infura.io/v3/<your API key>")
st.divider()

web3 = Web3(Web3.HTTPProvider(provider))

wei_value = 0

mmplace = '0x...'

contract_address_user = st.text_input('Safe contract address', mmplace)
if contract_address_user != '0x...':
    contract_address = web3.toChecksumAddress(contract_address_user)
    safe_contract = web3.eth.contract(address=contract_address, abi=json.loads(open('safe.abi').read()))

receiving_wallet_address = st.text_input('Receiving wallet address', mmplace)

nonative_token = st.toggle('Send non-native token', value=False)

if nonative_token:
    token_address = st.text_input('Token address', mmplace)
#    cold_wallet_address = st.text_input('Cold wallet address', '0x...', disabled=False)
    to = token_address
else:
    token_address = st.text_input('Token address', mmplace, disabled=True)
#    cold_wallet_address = st.text_input('Cold wallet address', '0x...', disabled=True)
    to = receiving_wallet_address
    data = '0x'

hot_wallet_address = st.text_input('Metamask address (hot wallet)', mmplace)

value_user = st.number_input("Value to send",)# step=1)
wei_value = int(value_user*(10**18))
v = "{0:#0{1}x}".format(wei_value,64)
if nonative_token:
    data = '0xa9059cbb000000000000000000000000' + receiving_wallet_address[2:] + '00' + v[2:]
    wei_value = 0

st.write(wei_value)
#st.write(data)

get_hash = st.checkbox("Get transaction hash (calls **getTransactionHash** on your contract)")


st.divider()

if get_hash:
    nonce = safe_contract.functions.nonce().call()
    st.write("Nonce: " +str(nonce))
    to = web3.toChecksumAddress(to)
    
    tx = safe_contract.functions.getTransactionHash(to,wei_value,data,0,0,0,0,'0x0000000000000000000000000000000000000000','0x0000000000000000000000000000000000000000',nonce).call()
    st.write("Now recover the private key by loading 'Shamir recover key mode' on the arduino and passing it your primary user share...")
    st.write("Once recovered, load 'Sign signature mode' and pass this transaction hash to the arduino:")
    st.code('<'+web3.toHex(tx)[2:]+'>')

arduino_sig = st.text_area('Enter Arduino signature of the transaction hash:', mmplace, height=75)
#    if arduino_sig != '0x...':

if arduino_sig != '0x...':

    d = {'to': to, 'value':wei_value, 'data':data, }
    st.write(d)
    final_signature_1b = '0x000000000000000000000000' + hot_wallet_address[2:] + '000000000000000000000000000000000000000000000000000000000000000001' + arduino_sig[2:] + '1b'
    final_signature_1c = '0x000000000000000000000000' + hot_wallet_address[2:] + '000000000000000000000000000000000000000000000000000000000000000001' + arduino_sig[2:] + '1c'

    st.divider()
    st.write('**Final Signature:**')
    st.write("(if using a blockchain explorer to interact with your contract, use one of these as the 'signature' field when calling **execTransaction**) with your hot metamask wallet")
    st.code(final_signature_1b)
    st.write('OR')
    st.code(final_signature_1c)


    if not nonative_token:
        raw_hex_1b = '0x6a7612020000000000000000000000' + '00' + to[2:] + '00' + v[2:] + '0000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000082000000000000000000000000' + hot_wallet_address[2:] + '000000000000000000000000000000000000000000000000000000000000000001' + arduino_sig[2:] + '1b' + '000000000000000000000000000000000000000000000000000000000000'
        raw_hex_1c = '0x6a7612020000000000000000000000' + '00' + to[2:] + '00' + v[2:] + '0000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000082000000000000000000000000' + hot_wallet_address[2:] + '000000000000000000000000000000000000000000000000000000000000000001' + arduino_sig[2:] + '1c' + '000000000000000000000000000000000000000000000000000000000000'

    else:
        raw_hex_1c = '0x6a7612020000000000000000000000' + '00' + to[2:] + '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000044' + 'a9059cbb000000000000000000000000' + receiving_wallet_address[2:] + '00' + v[2:] + '000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000082000000000000000000000000' + hot_wallet_address[2:] + '000000000000000000000000000000000000000000000000000000000000000001' + arduino_sig[2:] + '1c' + '000000000000000000000000000000000000000000000000000000000000'
        raw_hex_1b = '0x6a7612020000000000000000000000' + '00' + to[2:] + '0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000044' + 'a9059cbb000000000000000000000000' + receiving_wallet_address[2:] + '00' + v[2:] + '000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000082000000000000000000000000' + hot_wallet_address[2:] + '000000000000000000000000000000000000000000000000000000000000000001' + arduino_sig[2:] + '1b' + '000000000000000000000000000000000000000000000000000000000000'

    st.divider()
    

    st.write("**RAW HEX:**")
    
    st.write("Alternatively, you can call **execTransaction** by sending a transaction with a value of zero to your contract address and entering one of following in the **Hex data** field:")
    st.code(raw_hex_1b)
    st.write("OR")
    st.code(raw_hex_1c)



